[{"content":"之前的博客一直在使用pelican生成，最近想切到hugo试试看。笔者这里列一些小问题，纯记录：\n博客嵌入artalk评论，并配置artalk自适应夜间模式 artalk本身提供了Artalk.setDarkMode接口，使得其可以监听页面的相关内存片段，自适应做出light、dark色彩变换。 但其实这里存在一个问题那就是有的主题自带了切换白天、夜间模式的按钮，但切换时实际并没有改变artalk所监听的内存的值，这里提供了一个修改参考：\nwindow.addEventListener(\u0026#34;onColorSchemeChange\u0026#34;, (e) =\u0026gt; { Artalk.setDarkMode(document.documentElement.dataset.scheme==\u0026#34;dark\u0026#34;); }) 你需要把这个片段插入到artalk评论的shortcode的script内。其实关于这个修改，我也是改了好几版，才勉强把色彩同步过来，作为前端门外汉，改别人的前端项目真的是头痛呀。 关于这个，更多的可以参考下面的一些帖子：\nWeb适配深色模式自动跟随与手动切换的实践 artalk源码参考 gitea添加build action: deploy on commit TODO\n添加更多模版 在archetypes目录下创建一个新的模版leetcode.md，方便后面直接使用模版生成系列文章。\nls -la archetypes/ total 16 drwxr-xr-x 2 fan users 4096 Nov 19 03:26 . drwxr-xr-x 14 fan users 4096 Nov 19 01:49 .. -rw-r--r-- 1 fan users 102 Nov 12 10:04 default.md -rw-r--r-- 1 fan users 271 Nov 19 03:19 leetcode.md leetcode.md文件内可以如下：\n--- title: description: image: \u0026#34;https://xxxxx.png\u0026#34; slug: \u0026#34;{{ .File.ContentBaseName }}\u0026#34; date: \u0026#39;{{ .Date }}\u0026#39; categories: - leetcode tags: - \u0026#34;leetcode\u0026#34; - - series: leetcode题解系列 math: true draft: true --- 这时，可以使用如下命令创建新的系列文章：\nhugo new -k leetcode coding/leetcode/1887.md 参考： [1]. https://go.opensl.life/N3oNd\n","date":"2023-11-15T09:14:38Z","image":"https://s.md3.cn/imgs/i/2023/11/13/65510571a2ac5.jpg","permalink":"https://62742a40.github.io/articles/2023/11/%E5%8D%9A%E5%AE%A2%E8%A3%85%E4%BF%AE%E9%82%A3%E4%BA%9B%E4%BA%8B/","title":"博客装修那些事"},{"content":" 纯真而不欠闻达，善良而不失坚强，把生命高举在尘俗之上，又溶化于社会之中，这应当是我们这一代的共同追求。\n― 李克强, 1982年1月10日，北大法律系77级毕业前夕临别赠言 ","date":"2023-10-29T09:14:38Z","image":"https://62742a40.github.io/images/article-by-keqiang.jpg","permalink":"https://62742a40.github.io/articles/2023/10/%E4%B8%BA%E8%BF%99%E7%89%87%E6%96%B0%E7%BB%BF%E7%A5%9D%E7%A6%8F/","title":"愿你，纯真而不欠闻达，善良而不失坚强..."},{"content":"无重复字符的最长子串 给定一个字符串 $s$，返回其中不含有重复字符的最长子串的长度。 例1:\n输入: s = \u0026#34;abcabcbb\u0026#34; 输出: 3 例2:\n输入: s = \u0026#34;bbbbb\u0026#34; 输出: 1 例3:\n输入: s = \u0026#34;pwwkew\u0026#34; 输出: 3 约束条件：\n$0 \u0026lt;= s.length \u0026lt;= 5*10^4$ $s$ 由英文字母、数字、符号和空格组成 一上来，就容易想到的解法，但是比较耗内存：\n#include \u0026lt;string.h\u0026gt; int lengthOfLongestSubstring(char *s) { char bin[256] = {0}; unsigned short length = strlen(s); unsigned short ret = 0, this_ret = 0; for (int i = 0; i \u0026lt; length; i++) { if (bin[s[i]] != 0) { if (s[i - this_ret] == s[i]) continue; if (ret \u0026lt; this_ret) ret = this_ret; while (s[i - this_ret] != s[i]){ bin[s[i-this_ret]] = 0; this_ret --; } }else{ bin[s[i]] = 1; this_ret++; } } return ret\u0026lt;this_ret?this_ret:ret; } 提交截图(提交时，非现在状态)\n完整信息点击此连接查看\r","date":"2023-04-09T16:51:00Z","image":"https://s.md3.cn/imgs/i/2023/11/14/6552526cc22fd.png","permalink":"https://62742a40.github.io/coding/leetcode/3/","title":"3. Longest Substring Without Repeating Characters"},{"content":"找到两个已排序数列的中位数 给出两个已排序的数列 $nums1$ 和 $nums2$ ，两个数列长度分别为 $m$ 和 $n$ ，返回这两个数列的中位数。总体的时间复杂度应该是 $O(log(m+n))$ 。\n例1：\n输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解析：合并后数列为 [1,2,3]，中位数为 2。 例2：\n输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解析：合并后数列为 [1,2,3,4]，中位数为（2 + 3）/ 2 = 2.5。 约束条件：\n$nums1.length == m$ $nums2.length == n$ $0 \u0026lt;= m \u0026lt;= 1000$ $0 \u0026lt;= n \u0026lt;= 1000$ $1 \u0026lt;= m + n \u0026lt;= 2000$ $-106 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 106$ 一开始，写的代码比较直观，使用递归方法，一直移动边界，直到可以直接计算中位数\ndouble findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) { #define get_cn(s, n) \\ do \\ { \\ if (n % 2 == 0) \\ { \\ return (s[n / 2] + s[n / 2 - 1]) / 2.0; \\ } \\ else \\ { \\ return s[n / 2]; \\ } \\ } while (0); if (nums1Size == 0) { get_cn(nums2, nums2Size); } else if (nums2Size == 0) { get_cn(nums1, nums1Size); } else if (nums1Size == 1 \u0026amp;\u0026amp; nums2Size == 1) { return (nums1[0] + nums2[0]) / 2.; } if (nums1[0] \u0026gt;= nums2[0]) { nums2++; nums2Size--; if (nums2Size == 0) { nums1Size--; get_cn(nums1,nums1Size); } else if (nums1[nums1Size - 1] \u0026gt;= nums2[nums2Size - 1]) { nums1Size--; } else { nums2Size--; } } else { nums1++; nums1Size--; if (nums1Size == 0) { nums2Size--; get_cn(nums2,nums2Size); } else if (nums1[nums1Size - 1] \u0026gt;= nums2[nums2Size - 1]) { nums1Size--; } else { nums2Size--; } } return findMedianSortedArrays(nums1, nums1Size, nums2, nums2Size); } 后来把递归改为迭代，移动边界，直到满足计算条件\ndouble findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) { #define get_cn(s, n) \\ do \\ { \\ if (n % 2 == 0) \\ { \\ return (s[n / 2] + s[n / 2 - 1]) / 2.0; \\ } \\ else \\ { \\ return s[n / 2]; \\ } \\ } while (0); while (nums1Size \u0026gt;= 1 \u0026amp;\u0026amp; nums2Size \u0026gt;= 1 \u0026amp;\u0026amp; nums1Size + nums2Size \u0026gt; 2) { if (nums1[0] \u0026gt;= nums2[0]) { nums2++; nums2Size--; } else { nums1++; nums1Size--; } if (nums1[nums1Size - 1] \u0026gt;= nums2[nums2Size - 1]) { nums1Size--; } else { nums2Size--; } } if (nums1Size==0){ get_cn(nums2,nums2Size); }else if (nums2Size==0){ get_cn(nums1,nums1Size); }else{ return (nums1[0]+nums2[0])/2.0; } } 提交截图(提交时，非现在状态)\n完整信息点击此连接查看\r上面的算法效率并不高，实际上分析下，其时间复杂度其实是 $O(m+n)$ 。题解要求的复杂度是 $O(log(m+n))$，也即要求不能逐个寻找，应该有某种类似于快速梯度下降的法子，这里实际上二分搜索应该可以考虑下。\n二分搜索的递归解法如下:\ndouble findKthSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size, int kth) { if (nums1Size == 0) { return nums2[kth - 1]; } if (nums2Size == 0) { return nums1[kth - 1]; } if (kth == 1) { return nums2[0] \u0026gt; nums1[0] ? nums1[0] : nums2[0]; } int kth_left_half = kth / 2; int kth_right_half = kth / 2; if (nums1Size \u0026lt; kth_left_half) { kth_left_half = nums1Size; } if (nums2Size \u0026lt; kth_right_half) { kth_right_half = nums2Size; } if (nums1[kth_left_half - 1] \u0026lt;= nums2[kth_right_half - 1]) { nums1 += kth_left_half; nums1Size -= kth_left_half; kth -= kth_left_half; } else if (nums1[kth_left_half - 1] \u0026gt; nums2[kth_right_half - 1]) { nums2 += kth_right_half; nums2Size -= kth_right_half; kth -= kth_right_half; } return findKthSortedArrays(nums1, nums1Size, nums2, nums2Size, kth); } double findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) { // find (nums1Size+nums2Size)/2 th num int left_kth = (nums1Size+nums2Size+1)/2; int right_kth = (nums1Size+nums2Size+2)/2; return (findKthSortedArrays(nums1,nums1Size,nums2,nums2Size,left_kth)+ findKthSortedArrays(nums1,nums1Size,nums2,nums2Size,right_kth))/2.0; } 提交截图(提交时，非现在状态)\n完整信息点击此连接查看\r未完待续。。。解递归方法 ","date":"2023-04-09T16:51:00Z","image":"https://s.md3.cn/imgs/i/2023/11/14/6552526cc22fd.png","permalink":"https://62742a40.github.io/coding/leetcode/4/","title":"4.Median of Two Sorted Arrays"},{"content":" Warning\n\u0026ldquo;本页面可能的刷新慢问题\u0026rdquo; 使用webassembly技术生成的富文本包含的js和wasm资源可能会由于服务器下载速度限制出现加载慢问题，如果刷新慢请耐心等待，如果显示空白错误请重新刷新尝试\n写在前面 最早接触这个词时候大概是2020年左右，当时在某个网站上看到了基于网页跑的xp系统，感觉还挺新奇。最近重学cv课程，想着这次一定要实现一些算法。为了在网页演示基于C、C++、Rust、WebGL实现的图像处理算法，故而啃啃该技术的一些基本用法。\n注意：Firefox 52+ 和 Chrome 57+ 和最新版本的 Opera 已经默认启用，你也可以在 Firefox 47+ 中通过在 about:config 页面启用 javascript.options.wasm 字段获得支持，Chrome 51+ 和 Opera 38+ 可以在 chrome://flags 页面启用 Experimental WebAssembly 选项以支持 WebAssembly\n第一例比较简单，就是将一个基于c的printf函数的命令行模式程序编译到web assembly。 第二例是一个斐波那契数列生成器，使用c函数实现生成，js读取返回值 第三例是一个使用OpenGL实现的canvas功能的例子，渲染为120帧 上面的demo借鉴了以下的几个文章或者代码：\n[1]. https://github.com/timhutton/sdl-canvas-wasm.git\n[2]. https://go.opensl.life/X9pS8\n[3]. https://go.opensl.life/mfrfW\n[4]. https://go.opensl.life/12WYb\n","date":"2023-03-04T00:00:00Z","image":"https://s.md3.cn/imgs/i/2023/11/14/65525141e7c75.jpg","permalink":"https://62742a40.github.io/training/a-scratch-of-webassembly/","title":"web assembly初探"},{"content":"ubuntu下出现git log 外文正常显示、中文显示乱码的问题 描述：\n中文显示位尖括号 \u0026lt;E4\u0026gt;\u0026lt;B8\u0026gt;\u0026lt;B4\u0026gt;\u0026lt;E6\u0026gt;\u0026lt;97\u0026gt;\u0026lt;B6\u0026gt;\u0026lt;E4\u0026gt;\u0026lt;BF\u0026gt;\u0026lt;9D\u0026gt;\u0026lt;E5\u0026gt;\u0026lt;AD\u0026gt;\u0026lt;98\u0026gt;\n解决:\ngit config --global i18n.commitencoding utf-8 git config --global i18n.logoutputencoding gbk export LESSCHARSET=utf-8 git status时也会出现类似问题，但导致原因却不相同，可使用下面命令解决\ngit config --global core.quotepath false 跨系统基于挂载文件开发时常出现提交后，在另一系统上仍然存在多个未提交 描述：\n在多个系统间本地开发时，使用挂载目录进行编码、提交分离时，常常出现在一端提交，而另一端vs code提示多个未添加的变更，这常常是不同系统间filemode差异\n解决：\ngit config --add core.filemode false ","date":"2023-03-02T00:00:00Z","permalink":"https://62742a40.github.io/training/note-of-git/","title":"git使用问题记录"},{"content":"写这篇文章的目的是我有个囤服务器的坏毛病，服务器越来越多，每次配置服务器总是有一些重复的步骤，这里将它们记录下来，以备下次使用。\n（最近心水了Ansible这个工具，不过还没学会，所以这个教程还是用得上的）\nCentos新建用户并赋予SUDO权限 nusername=newuser useradd -m -s /bin/bash $nusername sudo usermod -a -G wheel $nusername passwd $nusername Centos防火墙配置 防火墙配置\nsudo yum install firewalld sudo firewall-cmd --state #防火墙状态 running sudo systemctl start firewalld sudo systemctl enable firewalld 打开端口 上面说明都是通过服务的配置文件打开端口，但是有时候不是所有服务都带有配置文件。在这种情况下，您有两种选择。您可以打开指定的端口，也可以定义新的FirewallD服务。\n例如，Plex服务器监听TCP协议32400端口，可使用\u0026ndash;add-port=选项在当前会话的public区域中打开32400端口。\n协议可以是tcp或udp。要验证是否已成功添加32400端口，请使用\u0026ndash;list-ports选项列出已打开的端口。\n要在重新启动后使端口32400保持打开状态，请使用\u0026ndash;permanent选项运行相同的命令，将规则添加到配置文件中。\n删除端口规则的语法与添加端口时的语法相同。只需使用\u0026ndash;remove-port选项即可。\nsudo firewall-cmd --zone=public --add-port=32400/tcp #打开端口 sudo firewall-cmd --zone=public --list-ports #列出 sudo firewall-cmd --zone=public --remove-port=32400/tcp # 参考链接： [1]. https://go.opensl.life/gV4IY\n","date":"2023-01-02T00:00:00Z","image":"https://s.md3.cn/imgs/i/2023/11/13/6552429aa90ef.jpg","permalink":"https://62742a40.github.io/training/server-setting/","title":"服务器配置备忘录"},{"content":"本文翻译于 \u0026ldquo;Root User and Password Inside a Docker Container\u0026rdquo;\n我们常使用root权限打开docker容器，显然这存在着一定的安全性问题。本文将讨论如何使用non-root用户创建docker镜像，来确保一些资源的安全性。\nFROM ubuntu:16.04 RUN apt-get update RUN useradd -m john USER john CMD /bin/bash 上面的例子创建了一个非root用户的镜像，正常启动后，进入容器即以john用户身份登录，此时使用包管理器安装软件包则会报出权限不足错误，需要切换至root用户。当你在烦恼切换时提示需要你输入root账户的密码时，有一个简单的方式可以直接以root方式登陆，那就是使用下面的命令。\ndocker exec -it -u 0 container_name bash 当然你也可以使用下面的命令\ndocker exec -it -u root container_name bash 如果说，你一定要在容器中为非root用户指定特别权限，你也可以安装sudo命令。下面的例子创建了一个非root用户john，并授予其sudo权限\nFROM ubuntu:16.04 RUN apt-get update \u0026amp;\u0026amp; apt-get -y install sudo RUN useradd -m john \u0026amp;\u0026amp; echo \u0026#34;john:john\u0026#34; | chpasswd \u0026amp;\u0026amp; adduser john sudo USER john CMD /bin/bash ","date":"2022-12-27T00:00:00Z","permalink":"https://62742a40.github.io/training/non-root-container-guide/","title":"容器中的root用户和密码"},{"content":"集成学习总结 本文译自ML-Ensembles-Methods 集成方法的目标是将具有给定学习算法构建的几个基本estimator的预测结果结合起来，以改善单个estimator上的泛化能力和鲁棒性。对于组合的机器学习技术，它结合了几个基础模型以产生一个最佳预测或者说集合是将各种学习者（不同模型）组合在一起的艺术，以即使模型的稳定性和预测能力得到调整。\n集合方法通常分为两类 平均方法。其驱动原理是独立地建立几个估计量，然后对它们的预测进行平均。平均而言，由于其方差减小，组合估计通常比任何单一基估计都好。例子:Bagging方法，随机森林方法等。 boosting方法，基本估计量是顺序建立的，每一个都试图减少组合估计量的偏差。其动机是将几个薄弱的模型组合成一个强大的集合。例如:AdaBoost，梯度树Boosting（GBDT, gradient boost decision tree）。 将来自不同模型的预测结合起来的三种最流行的方法是 Bagging : 从训练数据集的不同子样本中构建多个模型(通常是相同类型的)。 Boosting : 构建多个模型(通常是同一类型的)，其中每个模型都能学会修复链中先前模型的预测错误。 Voting : 建立多个模型(通常是不同类型的)和简单的统计数据(如计算平均值)来组合预测。 Bagging 方法 自动聚合或Bagging，包括了：从你的训练数据集(带替换)中提取多个样本，并为每个样本训练一个模型。最终的输出预测是所有子模型预测的平均值。\n本节所述的三种bagging模型如下 Bagged Decision Trees : Bagging决策树算法在具有高方差的算法中表现最好。一个流行的例子是决策树，通常在没有修剪的情况下构建 Random Forest : 训练数据集的随机森林样本被替换，但是树的构造方式降低了单个分类器之间的相关性。具体来说，不是在树的构造中贪婪地选择最好的拆分点，而是在每次拆分时只考虑一个随机的特征子集。 Extra Trees : Bagging的另一种修改，其中随机树是由训练数据集的样本构建的。 bagging 方法使用实例 完整内容点击此连接查看\nBoosting 方法 增强集成算法创建了一系列模型，这些模型试图在序列中纠正之前的模型的错误。模型创建后，可以根据其被证明的准确性进行预测，并将结果组合起来创建最终的输出预测。\n两种最常见的boosting集成机器学习算法是 AdaBoost : AdaBoost可能是第一个成功的增强集成算法。它的工作原理通常是根据分类的难易程度对数据集中的实例进行加权，从而允许算法在构建后续模型时更多更少地关注这些实例。 Stochastic Gradient Boosting(最好的) : 随机梯度增强(也称为梯度增强机)是最复杂的集成技术之一。这种技术也被证明可能是通过集成来提高性能的最佳技术之一 ","date":"2022-01-04T00:00:00Z","image":"https://s.md3.cn/imgs/i/2023/11/13/6552429483e37.jpg","permalink":"https://62742a40.github.io/training/ensemble-learning/","title":"ml Ensembles Methods"},{"content":"音频数据处理入门参考 本文参考自kaggle的一个文章，里面的代码所用的依赖版本过旧，可能不能正常运行，但总体思想路依然如此。\n完整内容点击此连接查看\n本文参考来源 [1]. kaggle\n","date":"2021-12-30T00:00:00Z","image":"https://s.md3.cn/imgs/i/2023/11/13/65524295acf11.jpg","permalink":"https://62742a40.github.io/training/beginner_s-guide-to-audio-data/","title":"Beginner's Guide to Audio Data"},{"content":"最长有效括号 给定一个仅包含字符 \u0026lsquo;(\u0026rsquo; 和 \u0026lsquo;)\u0026rsquo; 的字符串，返回最长有效（格式正确）括号的长度子串。 例1：\n输入： s = \u0026#34;(()\u0026#34; 输出： 2 解析：最长的有效括号子串是 \u0026#34;()\u0026#34;。 例2：\n输入： s = \u0026#34;)()())\u0026#34; 输出： 4 解析：最长的有效括号子串是 \u0026#34;()()\u0026#34;。 例3：\n输入： s = \u0026#34;\u0026#34; 输出： 0 约束条件：\n$0 \u0026lt;= s.length \u0026lt;= 3 * 10^4$ s[i]是\u0026rsquo;(\u0026rsquo;，或者\u0026rsquo;)\u0026rsquo; 此题虽然被leetcode标注为难等级，但是其实和最长回文应该属于差不多等级难度。这里贴出我的解法，该解法目前在leetcode打榜中占据了优势位置：\n#include \u0026lt;string.h\u0026gt; // @lc code=start int longestValidParentheses(char *s) { unsigned short length = strlen(s); // 动态规划 is too much memory cost // cutoff left right bound while (length \u0026gt; 0 \u0026amp;\u0026amp; s[0] != \u0026#39;(\u0026#39;) { s++; length--; } while (length \u0026gt; 0 \u0026amp;\u0026amp; s[length - 1] != \u0026#39;)\u0026#39;) { length--; } s[length] = 0; if (length \u0026lt;= 2) return length == 2 ? 2 : 0; int ret = 0; unsigned short lnum = 1, rnum = 0, delta = 0; for (int i = 1; i \u0026lt; length; i++) { if (s[i] == \u0026#39;(\u0026#39;) lnum += 1; else rnum += 1; if (rnum \u0026gt; lnum) { if (lnum \u0026lt;\u0026lt; 1 \u0026gt; ret) ret = lnum \u0026lt;\u0026lt; 1; lnum = 0; rnum = 0; delta = i + 1; } } if (lnum == rnum) return rnum \u0026lt;\u0026lt; 1 \u0026lt; ret ? ret : rnum \u0026lt;\u0026lt; 1; if (rnum \u0026lt;\u0026lt; 1 \u0026lt;= ret) return ret; s = s + delta; length -= delta; lnum = 0, rnum = 1; for (int i = length - 2; i \u0026gt;= 0; i--) { if (s[i] == \u0026#39;)\u0026#39;) rnum += 1; else lnum += 1; if (lnum \u0026gt; rnum) { if (rnum \u0026lt;\u0026lt; 1 \u0026gt; ret) ret = rnum \u0026lt;\u0026lt; 1; lnum = 0; rnum = 0; } } return lnum \u0026lt;\u0026lt; 1 \u0026lt; ret ? ret : lnum \u0026lt;\u0026lt; 1; } 提交截图(提交时，非现在状态)\n完整信息点击此连接查看\r","date":"2021-12-26T17:23:00Z","image":"https://s.md3.cn/imgs/i/2023/11/14/6552526cc22fd.png","permalink":"https://62742a40.github.io/coding/leetcode/32/","title":"32.Longest Valid Parentheses"},{"content":"最长回文子串 给出一个字符串 $s$，返回其最长的回文子串。 例1：\n输入：s = \u0026#34;babad\u0026#34; 输出：\u0026#34;bab\u0026#34; 解析：\u0026#34;aba\u0026#34; 也是一个有效的答案。 例2：\n输入：s = \u0026#34;cbbd\u0026#34; 输出：\u0026#34;bb\u0026#34; 约束条件：\n$1 \u0026lt;= s.length \u0026lt;= 1000$ $s$ 仅仅包含数字和英文字母 一般来说，这道题首先想到的教科书式解法是动态规划，这里解法使用early-stop规则，内存占用也降低：\n#include \u0026lt;string.h\u0026gt; char *longestPalindrome(char *s) { short mlidx = 0, mridx = 0, lidx = 0, ridx = 0; short length = strlen(s); if (length \u0026lt;= 1) return s; if (length == 2) return s[0] == s[1] ? s : s + 1; for (int i = 1; i \u0026lt; length - 1; i++) { lidx = ridx = i; while (lidx \u0026gt; 0 \u0026amp;\u0026amp; ridx \u0026lt; length - 1 \u0026amp;\u0026amp; s[lidx - 1] == s[ridx + 1]) { lidx--; ridx++; } if (ridx - lidx \u0026gt; mridx - mlidx) { mridx = ridx; mlidx = lidx; } } if (mlidx == mridx) { if (s[0] == s[1]) { mlidx = 0; mridx = 1; } else if (s[length - 2] == s[length - 1]) { mlidx = length - 2; mridx = length - 1; } } if (length \u0026gt; 3) { for (int i = 1; i \u0026lt; length - 2; i++) { if (s[i] == s[i + 1]) { lidx = i; ridx = i + 1; while (lidx \u0026gt; 0 \u0026amp;\u0026amp; ridx \u0026lt; length - 1 \u0026amp;\u0026amp; s[lidx - 1] == s[ridx + 1]) { lidx--; ridx++; } } if (ridx - lidx \u0026gt; mridx - mlidx) { mridx = ridx; mlidx = lidx; } } } s[mridx + 1] = \u0026#39;\\0\u0026#39;; return s + mlidx; } 提交截图(提交时，非现在状态)\n完整信息点击此连接查看\r","date":"2021-12-26T17:23:00Z","image":"https://s.md3.cn/imgs/i/2023/11/14/6552526cc22fd.png","permalink":"https://62742a40.github.io/coding/leetcode/5/","title":"5.Longest Palindromic Substring"},{"content":"本文为内容摘取翻译，参考于以下链接：\nLaTeX in Markdown LaTeX Cheatsheet a note on LaTeX notebook [cheatsheet for Latex,using markdown for markup.][https://gist.github.com/LKS90/252ac41bd4a173be35b0]\nDescription Cheatsheet for LaTex, using Markdown for markup. I use this with atom.io and :package:markdown-preview-plus to write math stuff. :package:keyboard-localization is necessary when using an international layout (like [swiss] german).\nFurther Reference and source: ftp://ftp.ams.org/pub/tex/doc/amsmath/short-math-guide.pdf\nExample expressions / functions Input Rendered $a = b + c − d$ $a = b + c − d$ $\\sqrt{?\\frac{\\pi}{2}}$ $\\sqrt{\\frac{\\pi}{2}}$ $y = a x_1^2 + b x_2 + c$ $y = a x_1^2 + b x_2 + c$ Special characters / Symbols ###Latin: #####No dot:\n\\imath $\\rightarrow$ $\\imath$, \\jmath $\\rightarrow$ $\\jmath$\n#####Hat:\n\\hat{\\imath} $\\rightarrow$ $\\hat{\\imath}$, \\hat{\\jmath} $\\rightarrow$ $\\hat{\\jmath}$\n###Greek Letters: #####Capital:\nLaTex LaTex \\Gamma Γ \\Delta ∆ \\Lambda Λ \\Phi Φ \\Pi Π \\Psi Ψ \\Sigma Σ \\Theta Θ \\Upsilon Υ \\Xi Ξ \\Omega Ω #####Lowercase:\nLaTex LaTex \\alpha α \\nu ν \\beta β \\kappa κ \\gamma γ \\lambda λ \\delta δ \\mu µ \\epsilon ϵ \\zeta ζ \\eta η \\theta θ \\iota ι \\xi ξ \\pi π \\rho ρ \\sigma σ \\tau τ \\upsilon υ \\phi φ \\chi χ \\psi ψ \\omega ω #####Other:\nLaTex LaTex \\digamma ϝ varepsilon ε \\varkappa ϰ \\varphi ϕ \\varpi ϖ \\varrho ϱ \\varsigma ς \\vartheta ϑ \\eth ð \\hbar $\\hbar$ ###Other: ####Other Symbols\nLaTex LaTex \\partial ∂ \\infty ∞ \\wedge ∧ \\vee ∨ \\neg \\not ¬ \\bot ⊥ \\top ⊤ \\nabla ∇ \\varnothing ∅ \\angle ∠ \\measuredangle ∡ \\surd √ \\forall ∀ \\exists ∃ \\nexists ∄ ####Relational Symbols\nLaTex LaTex \\hookrightarrow ↪ \\Rightarrow ⇒ \\rightarrow → \\Leftrightarrow ⇔ \\nrightarrow ↛ \\mapsto $\\mapsto$ \\geq ≥ \\leq ≤ \\equiv ≡ \\sim ∼ \\gg ≫ \\ll ≪ \\subset ⊂ \\subseteq ⊆ \\in ∈ \\notin ∉ \\mid $\\mid$ \\propto ∝ \\perp ⊥ \\parallel ∥ \\vartriangle $\\vartriangle$ ####Binary operators\nLaTex LaTex \\wedge ∧ \\vee ∨ \\neg``\\not ¬ ####Cumulative operators\nLaTex LaTex \\int ∫ \\iint $\\iint$ \\iiint $\\iiint$ \\idotsint $\\idotsint$ \\prod $\\prod$ \\sum $\\sum$ \\bigcup $\\bigcup$ \\bigcap $\\bigcap$ ####Named operators $\\arccos$, $\\arcsin$, $\\arctan$, $\\arg$, $\\cos$, $\\cosh$, $\\cot$, $\\coth$, $\\deg$, $\\det$, $\\dim$, $\\exp$, $\\gcd$, $\\hom$, $\\inf$, $\\injlim$, $\\lg$, $\\lim$, $\\liminf$, $\\limsup$, $\\ln$, $\\log$, $\\max$, $\\min$, $\\Pr$, $\\projlim$, $\\sec$, $\\sin$, $\\sinh$, $\\sup$\n","date":"2021-12-22T15:00:00Z","image":"https://s.md3.cn/imgs/i/2023/11/13/65510574e06c2.jpg","permalink":"https://62742a40.github.io/training/note-of-latex/","title":"latex笔记"}]